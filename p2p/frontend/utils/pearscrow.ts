import { ethers } from 'ethers';
import { MOCK_AVS_ADDRESS, PEARSCROW_ADDRESS } from './constants';

/**
 * PearScrow contract ABI fragments for the needed functions
 */
export const PearScrowABI = [
  'function createOrder(address token, address seller, uint256 amount) external',
  'function releaseOrder(bytes32 orderId, bool result) external',
  'function orders(bytes32 orderId) external view returns (address token, address buyer, address seller, uint256 amount, bool released, uint256 createdAt)',
  'function provideLiquidity(address token, uint256 amount) external',
  'function withdrawLiquidity(address token, uint256 amount) external',
  'function sellerBalances(address seller, address token) external view returns (uint256)',
  'function cancelOrder(bytes32 orderId) external'
];

/**
 * Order data structure as returned by the contract
 */
export interface Order {
  token: string;
  buyer: string;
  seller: string;
  amount: ethers.BigNumber;
  released: boolean;
  createdAt: ethers.BigNumber;
}

/**
 * Creates a PearScrow contract instance
 * @param signerOrProvider - Ethers signer or provider
 * @returns Ethers contract instance
 */
export function getPearScrowContract(signerOrProvider: ethers.Signer | ethers.providers.Provider): ethers.Contract {
  // Ensure the contract address has the correct checksum
  const checksummedAddress = ethers.utils.getAddress(PEARSCROW_ADDRESS);
  
  return new ethers.Contract(
    checksummedAddress,
    PearScrowABI,
    signerOrProvider
  );
}

/**
 * Creates a new order in the PearScrow escrow system
 * @param signer - Ethers signer of the buyer
 * @param tokenAddress - Address of the token used for payment
 * @param sellerAddress - Address of the seller
 * @param amount - Amount of tokens to be escrowed (in wei)
 * @returns Transaction response
 */
export async function createOrder(
  signer: ethers.Signer,
  tokenAddress: string,
  sellerAddress: string,
  amount: ethers.BigNumberish
): Promise<ethers.ContractTransaction> {
  // Ensure addresses are correctly checksummed
  const checksummedTokenAddress = ethers.utils.getAddress(tokenAddress);
  const checksummedSellerAddress = ethers.utils.getAddress(sellerAddress);
  
  const contract = getPearScrowContract(signer);
  return contract.createOrder(checksummedTokenAddress, checksummedSellerAddress, amount);
}

/**
 * Releases an order with the associated orderId
 * @param signer - Ethers signer 
 * @param orderId - Bytes32 orderId as generated by the contract
 * @param result - Result from the AVS (typically true for success)
 * @returns Transaction response
 */
export async function releaseOrder(
  signer: ethers.Signer,
  orderId: string,
  result: boolean
): Promise<ethers.ContractTransaction> {
  // OrderId should be a valid bytes32 hex string

  
  const contract = getPearScrowContract(signer);
  return contract.releaseOrder(orderId, result);
}

/**
 * Retrieves order details from the contract
 * @param provider - Ethers provider
 * @param orderId - Bytes32 orderId to fetch
 * @returns Order details
 */
export async function getOrder(
  provider: ethers.providers.Provider,
  orderId: string
): Promise<Order> {
  
  const contract = getPearScrowContract(provider);
  return contract.orders(orderId);
}

/**
 * Calculates orderId hash as the contract would
 * @param buyer - Buyer address
 * @param seller - Seller address
 * @param token - Token address
 * @param amount - Amount of tokens (in wei)
 * @param timestamp - Timestamp in seconds
 * @returns Bytes32 orderId hash
 */
export function calculateOrderId(
  buyer: string,
  seller: string,
  token: string,
  amount: ethers.BigNumberish,
  timestamp: number
): string {
  // Ensure addresses are correctly checksummed
  const checksummedBuyer = ethers.utils.getAddress(buyer);
  const checksummedSeller = ethers.utils.getAddress(seller);
  const checksummedToken = ethers.utils.getAddress(token);
  
  return ethers.utils.keccak256(
    ethers.utils.solidityPack(
      ['address', 'address', 'address', 'uint256', 'uint256'],
      [checksummedBuyer, checksummedSeller, checksummedToken, amount, timestamp]
    )
  );
} 